<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNAKE - Fantasy Adventure</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="game-container">
        <canvas id="particles"></canvas>
        <div id="boss-sprite"></div>
        <canvas id="game-canvas"></canvas>
        <div id="hud">
            <div>Level: <span id="level-display">1</span></div>
            <div>Length: <span id="length-display">3</span> / <span id="target-display">10</span></div>
            <div>Speed: <span id="speed-display">5</span> c/s</div>
            <div id="biome-display">Enchanted Forest</div>
            <div id="boss-hud" class="boss-hud hidden">
                <div id="boss-name">FOREST SPIRIT</div>
                <div>Stage: <span id="boss-stage">1</span>/3</div>
            </div>
        </div>
        <div id="boss-warning" class="hidden">BOSS INCOMING!</div>
        <div id="speed-boost-indicator" class="speed-boost hidden">SPEED BOOST!</div>

        <div id="start-screen">
            <h1>SNAKE</h1>
            <p class="stats" id="biome-subtitle">Enchanted Forest</p>
            <button class="btn" id="start-btn">START</button>
            <div class="level-select">
                <label>Level:</label>
                <input type="number" id="level-input" min="1" max="15" value="1">
                <button class="btn" id="go-btn">GO</button>
            </div>
        </div>

        <div id="game-over-screen" class="hidden">
            <h2>GAME OVER</h2>
            <p class="stats">Level: <span id="final-level">1</span></p>
            <p class="stats">Length: <span id="final-length">3</span></p>
            <button class="btn" id="restart-btn">RESTART</button>
            <button class="btn" id="menu-btn">MENU</button>
        </div>

        <div id="level-complete-screen" class="hidden">
            <h2 id="level-complete-title">LEVEL COMPLETE!</h2>
            <p class="stats">Level <span id="completed-level">1</span> cleared!</p>
            <button class="btn" id="next-level-btn">NEXT LEVEL</button>
        </div>
    </div>

    <script>
        // ============================================
        // GAME CONFIGURATION
        // ============================================
        const CONFIG = {
            gridSize: 20,
            cellSize: 24,
            maxLevel: 15
        };

        // Speed per level range (cells/sec) - using array (index 0 unused)
        const LEVEL_SPEEDS = [0, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 8, 8, 8, 8, 8];

        // Level requirements - using array (index 0 unused)
        const LEVEL_TARGETS = [0, 10, 15, 20, 25, 30, 35, 40, 45, 48, 50, 50, 50, 50, 50, 50];

        // Get speed for a level
        function getLevelSpeed(level) {
            const lvl = Number(level);
            if (lvl >= 1 && lvl <= 5) return 5;
            if (lvl >= 6 && lvl <= 10) return 6;
            if (lvl >= 11 && lvl <= 15) return 8;
            return 5;
        }

        // Get target length for a level
        function getLevelTarget(level) {
            const lvl = Number(level);
            if (lvl <= 0) return 10;
            if (lvl > 15) return 50;
            return LEVEL_TARGETS[lvl];
        }

        // Obstacles per level (cycles within biome)
        function getObstacleCount(level) {
            const lvl = Number(level);
            const posInCycle = ((lvl - 1) % 5);
            if (posInCycle === 4) return 0; // Boss level
            return posInCycle;
        }

        // Biome definitions
        const BIOMES = {
            forest: {
                name: 'Enchanted Forest',
                bodyBg: '#0a1f0a',
                border: '#2d5a27',
                shadow: 'rgba(50, 205, 50, 0.3)',
                hudColor: '#7cfc00',
                background: '#0d2818',
                tile1: '#1a4d2e',
                tile2: '#163d26',
                snakeHead: '#7cfc00',
                snakeBody: '#32cd32',
                snakeTail: '#228b22',
                food: '#ff69b4',
                foodGlow: 'rgba(255, 105, 180, 0.6)',
                obstacle: '#4a3728',
                obstacleAccent: '#3d6b4f',
                warning: '#ff4444',
                particleColor: [144, 238, 144]
            },
            volcanic: {
                name: 'Volcanic Cavern',
                bodyBg: '#1a0a0a',
                border: '#8b2500',
                shadow: 'rgba(255, 69, 0, 0.3)',
                hudColor: '#ff6600',
                background: '#1a0505',
                tile1: '#2d1a1a',
                tile2: '#251212',
                snakeHead: '#ff6600',
                snakeBody: '#ff4500',
                snakeTail: '#cc3300',
                food: '#ffcc00',
                foodGlow: 'rgba(255, 200, 0, 0.6)',
                obstacle: '#333333',
                obstacleAccent: '#ff4400',
                warning: '#ffff00',
                particleColor: [255, 100, 50]
            },
            frozen: {
                name: 'Frozen Tundra',
                bodyBg: '#0a0a1f',
                border: '#4a6fa5',
                shadow: 'rgba(100, 149, 237, 0.3)',
                hudColor: '#87ceeb',
                background: '#0a1020',
                tile1: '#1a2540',
                tile2: '#152035',
                snakeHead: '#00ffff',
                snakeBody: '#40e0d0',
                snakeTail: '#20b2aa',
                food: '#ff69b4',
                foodGlow: 'rgba(255, 105, 180, 0.6)',
                obstacle: '#6a8caf',
                obstacleAccent: '#a0d8ef',
                warning: '#ff4444',
                particleColor: [255, 255, 255]
            }
        };

        function getBiome(level) {
            const lvl = Number(level);
            if (lvl <= 5) return BIOMES.forest;
            if (lvl <= 10) return BIOMES.volcanic;
            return BIOMES.frozen;
        }

        function getBiomeKey(level) {
            const lvl = Number(level);
            if (lvl <= 5) return 'forest';
            if (lvl <= 10) return 'volcanic';
            return 'frozen';
        }

        function getBossLevel(level) {
            const lvl = Number(level);
            return lvl % 5 === 0;
        }

        function getBossType(level) {
            const lvl = Number(level);
            if (lvl === 5) return 'forestSpirit';
            if (lvl === 10) return 'volcanoDragon';
            if (lvl === 15) return 'iceGiant';
            return null;
        }

        // ============================================
        // GAME STATE
        // ============================================
        let gameState = {
            level: 1,
            snake: [],
            direction: { x: 1, y: 0 },
            nextDirection: { x: 1, y: 0 },
            food: null,
            obstacles: [],
            gameStatus: 'menu',
            lastMoveTime: 0,
            moveInterval: 1000 / 5,
            currentSpeed: 5,
            isBossLevel: false,
            bossType: null,
            bossStage: 1,
            // Forest Spirit
            bossAcorns: [],
            bossWarnings: [],
            bossDropTimer: 0,
            // Volcano Dragon
            lavaPools: [],
            lavaWarnings: [],
            // Ice Giant
            icePatches: [],
            icicles: [],
            icicleWarnings: [],
            snowballTimer: 0,
            icicleTimer: 0,
            isSpeedBoosted: false,
            speedBoostTimer: 0,
            // Particles
            particles: []
        };

        // ============================================
        // CANVAS SETUP
        // ============================================
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const particleCanvas = document.getElementById('particles');
        const particleCtx = particleCanvas.getContext('2d');

        canvas.width = CONFIG.gridSize * CONFIG.cellSize;
        canvas.height = CONFIG.gridSize * CONFIG.cellSize;
        particleCanvas.width = canvas.width;
        particleCanvas.height = canvas.height + 150;

        // DOM Elements
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const levelCompleteScreen = document.getElementById('level-complete-screen');
        const bossWarning = document.getElementById('boss-warning');
        const bossHud = document.getElementById('boss-hud');
        const bossSprite = document.getElementById('boss-sprite');
        const speedBoostIndicator = document.getElementById('speed-boost-indicator');

        // ============================================
        // THEME APPLICATION
        // ============================================
        function applyBiomeTheme(biome) {
            document.body.style.background = biome.bodyBg;
            canvas.style.borderColor = biome.border;
            canvas.style.boxShadow = `0 0 20px ${biome.shadow}, inset 0 0 60px rgba(0, 0, 0, 0.5)`;
            document.getElementById('hud').style.color = biome.hudColor;
            document.getElementById('biome-display').textContent = biome.name;

            // Update screens
            startScreen.style.background = `rgba(${hexToRgb(biome.bodyBg)}, 0.95)`;
            gameOverScreen.style.background = `rgba(${hexToRgb(biome.bodyBg)}, 0.95)`;
            levelCompleteScreen.style.background = `rgba(${hexToRgb(biome.bodyBg)}, 0.95)`;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ?
                `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` :
                '0, 0, 0';
        }

        // ============================================
        // PARTICLES
        // ============================================
        function initParticles(biomeKey) {
            gameState.particles = [];
            const count = biomeKey === 'frozen' ? 50 : 30;

            for (let i = 0; i < count; i++) {
                const p = {
                    x: Math.random() * particleCanvas.width,
                    y: Math.random() * particleCanvas.height,
                    size: Math.random() * 3 + 1,
                    brightness: Math.random(),
                    brightnessDir: Math.random() > 0.5 ? 1 : -1
                };

                if (biomeKey === 'forest') {
                    p.speedX = (Math.random() - 0.5) * 0.5;
                    p.speedY = (Math.random() - 0.5) * 0.5;
                } else if (biomeKey === 'volcanic') {
                    p.speedX = (Math.random() - 0.5) * 0.3;
                    p.speedY = -Math.random() * 1.5 - 0.5; // Rising embers
                } else if (biomeKey === 'frozen') {
                    p.speedX = (Math.random() - 0.5) * 0.5;
                    p.speedY = Math.random() * 1 + 0.3; // Falling snow
                }

                gameState.particles.push(p);
            }
        }

        function updateParticles(biome, biomeKey) {
            particleCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
            const [r, g, b] = biome.particleColor;

            gameState.particles.forEach(p => {
                p.x += p.speedX;
                p.y += p.speedY;

                // Wrap around
                if (p.x < 0) p.x = particleCanvas.width;
                if (p.x > particleCanvas.width) p.x = 0;
                if (biomeKey === 'volcanic') {
                    if (p.y < 0) p.y = particleCanvas.height;
                } else {
                    if (p.y < 0) p.y = particleCanvas.height;
                    if (p.y > particleCanvas.height) p.y = 0;
                }

                // Update brightness (for fireflies/embers)
                if (biomeKey !== 'frozen') {
                    p.brightness += p.brightnessDir * 0.02;
                    if (p.brightness > 1) { p.brightness = 1; p.brightnessDir = -1; }
                    if (p.brightness < 0.2) { p.brightness = 0.2; p.brightnessDir = 1; }
                } else {
                    p.brightness = 0.8;
                }

                const alpha = p.brightness * 0.8;

                // Draw particle
                particleCtx.beginPath();
                particleCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                particleCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                particleCtx.fill();

                // Glow effect (not for snow)
                if (biomeKey !== 'frozen') {
                    particleCtx.beginPath();
                    particleCtx.arc(p.x, p.y, p.size * 3, 0, Math.PI * 2);
                    const gradient = particleCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 3);
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${alpha * 0.5})`);
                    gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                    particleCtx.fillStyle = gradient;
                    particleCtx.fill();
                }
            });

            // Aurora effect for frozen biome
            if (biomeKey === 'frozen') {
                drawAurora();
            }
        }

        function drawAurora() {
            const time = Date.now() / 2000;
            particleCtx.globalAlpha = 0.15;

            for (let i = 0; i < 3; i++) {
                const gradient = particleCtx.createLinearGradient(0, 0, particleCanvas.width, 100);
                gradient.addColorStop(0, `hsl(${(time * 30 + i * 40) % 360}, 70%, 50%)`);
                gradient.addColorStop(0.5, `hsl(${(time * 30 + 120 + i * 40) % 360}, 70%, 50%)`);
                gradient.addColorStop(1, `hsl(${(time * 30 + 240 + i * 40) % 360}, 70%, 50%)`);

                particleCtx.fillStyle = gradient;
                particleCtx.beginPath();
                for (let x = 0; x < particleCanvas.width; x += 10) {
                    const y = 30 + Math.sin(x / 50 + time + i) * 20 + i * 15;
                    if (x === 0) particleCtx.moveTo(x, y);
                    else particleCtx.lineTo(x, y);
                }
                particleCtx.lineTo(particleCanvas.width, 100);
                particleCtx.lineTo(0, 100);
                particleCtx.fill();
            }

            particleCtx.globalAlpha = 1;
        }

        // ============================================
        // SNAKE FUNCTIONS
        // ============================================
        function initSnake() {
            const startX = Math.floor(CONFIG.gridSize / 4);
            const startY = Math.floor(CONFIG.gridSize / 2);
            gameState.snake = [
                { x: startX, y: startY },
                { x: startX - 1, y: startY },
                { x: startX - 2, y: startY }
            ];
            gameState.direction = { x: 1, y: 0 };
            gameState.nextDirection = { x: 1, y: 0 };
        }

        function drawSnake(biome) {
            gameState.snake.forEach((segment, index) => {
                const x = segment.x * CONFIG.cellSize;
                const y = segment.y * CONFIG.cellSize;
                const size = CONFIG.cellSize - 2;

                if (index === 0) {
                    ctx.fillStyle = biome.snakeHead;
                    ctx.fillRect(x + 1, y + 1, size, size);

                    // Eyes
                    ctx.fillStyle = '#000';
                    const eyeSize = 4;
                    const eyeOffset = 5;
                    if (gameState.direction.x === 1) {
                        ctx.fillRect(x + size - eyeOffset, y + 5, eyeSize, eyeSize);
                        ctx.fillRect(x + size - eyeOffset, y + size - 7, eyeSize, eyeSize);
                    } else if (gameState.direction.x === -1) {
                        ctx.fillRect(x + eyeOffset - 2, y + 5, eyeSize, eyeSize);
                        ctx.fillRect(x + eyeOffset - 2, y + size - 7, eyeSize, eyeSize);
                    } else if (gameState.direction.y === 1) {
                        ctx.fillRect(x + 5, y + size - eyeOffset, eyeSize, eyeSize);
                        ctx.fillRect(x + size - 7, y + size - eyeOffset, eyeSize, eyeSize);
                    } else {
                        ctx.fillRect(x + 5, y + eyeOffset - 2, eyeSize, eyeSize);
                        ctx.fillRect(x + size - 7, y + eyeOffset - 2, eyeSize, eyeSize);
                    }
                } else if (index === gameState.snake.length - 1) {
                    ctx.fillStyle = biome.snakeTail;
                    ctx.fillRect(x + 3, y + 3, size - 4, size - 4);
                } else {
                    ctx.fillStyle = biome.snakeBody;
                    ctx.fillRect(x + 1, y + 1, size, size);
                }
            });
        }

        function moveSnake() {
            gameState.direction = { ...gameState.nextDirection };

            const head = gameState.snake[0];
            const newHead = {
                x: head.x + gameState.direction.x,
                y: head.y + gameState.direction.y
            };

            // Check wall collision
            if (newHead.x < 0 || newHead.x >= CONFIG.gridSize ||
                newHead.y < 0 || newHead.y >= CONFIG.gridSize) {
                gameOver();
                return;
            }

            // Check self collision
            if (gameState.snake.some(s => s.x === newHead.x && s.y === newHead.y)) {
                gameOver();
                return;
            }

            // Check obstacle collision
            if (gameState.obstacles.some(o => o.x === newHead.x && o.y === newHead.y)) {
                gameOver();
                return;
            }

            // Check boss-specific collisions
            if (gameState.bossAcorns.some(a => a.x === newHead.x && a.y === newHead.y)) {
                gameOver();
                return;
            }
            if (gameState.lavaPools.some(p => p.cells.some(c => c.x === newHead.x && c.y === newHead.y))) {
                gameOver();
                return;
            }
            if (gameState.icicles.some(i => i.x === newHead.x && i.y === newHead.y)) {
                gameOver();
                return;
            }

            // Check ice patch for speed boost
            if (gameState.bossType === 'iceGiant') {
                const onIcePatch = gameState.icePatches.some(patch =>
                    newHead.x >= patch.x && newHead.x < patch.x + 4 &&
                    newHead.y >= patch.y && newHead.y < patch.y + 4
                );
                if (onIcePatch && !gameState.isSpeedBoosted) {
                    gameState.isSpeedBoosted = true;
                    gameState.speedBoostTimer = 500;
                    gameState.moveInterval = 1000 / (gameState.currentSpeed * 1.5);
                    speedBoostIndicator.classList.remove('hidden');
                }
            }

            gameState.snake.unshift(newHead);

            // Check food collision
            if (gameState.food && newHead.x === gameState.food.x && newHead.y === gameState.food.y) {
                spawnFood();
                updateHUD();

                if (gameState.snake.length >= getLevelTarget(gameState.level)) {
                    levelComplete();
                    return;
                }
            } else {
                gameState.snake.pop();
            }
        }

        // ============================================
        // DRAWING FUNCTIONS
        // ============================================
        function drawBackground(biome) {
            ctx.fillStyle = biome.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let x = 0; x < CONFIG.gridSize; x++) {
                for (let y = 0; y < CONFIG.gridSize; y++) {
                    ctx.fillStyle = (x + y) % 2 === 0 ? biome.tile1 : biome.tile2;
                    ctx.fillRect(x * CONFIG.cellSize, y * CONFIG.cellSize, CONFIG.cellSize, CONFIG.cellSize);
                }
            }
        }

        function drawFood(biome) {
            if (!gameState.food) return;

            const x = gameState.food.x * CONFIG.cellSize + CONFIG.cellSize / 2;
            const y = gameState.food.y * CONFIG.cellSize + CONFIG.cellSize / 2;
            const time = Date.now() / 500;
            const pulseSize = Math.sin(time) * 2 + 8;

            // Glow
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, pulseSize * 2);
            gradient.addColorStop(0, biome.foodGlow);
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.beginPath();
            ctx.arc(x, y, pulseSize * 2, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Food
            ctx.beginPath();
            ctx.arc(x, y, pulseSize, 0, Math.PI * 2);
            ctx.fillStyle = biome.food;
            ctx.fill();

            // Highlight
            ctx.beginPath();
            ctx.arc(x - 2, y - 2, 3, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
        }

        function drawObstacles(biome, biomeKey) {
            gameState.obstacles.forEach(obs => {
                const x = obs.x * CONFIG.cellSize;
                const y = obs.y * CONFIG.cellSize;
                const size = CONFIG.cellSize - 2;

                ctx.fillStyle = biome.obstacle;
                ctx.fillRect(x + 1, y + 1, size, size);

                ctx.fillStyle = biome.obstacleAccent;
                if (biomeKey === 'forest') {
                    ctx.fillRect(x + 2, y + 2, 8, 6);
                    ctx.fillRect(x + size - 10, y + size - 8, 8, 6);
                } else if (biomeKey === 'volcanic') {
                    // Glowing cracks
                    ctx.fillRect(x + 4, y + 4, 3, 14);
                    ctx.fillRect(x + 10, y + 8, 8, 3);
                } else if (biomeKey === 'frozen') {
                    // Ice highlights
                    ctx.fillRect(x + 2, y + 2, 6, 3);
                    ctx.fillRect(x + 4, y + 6, 4, 10);
                }
            });
        }

        // ============================================
        // BOSS SPRITES
        // ============================================
        function drawBossSprite() {
            if (!gameState.isBossLevel) {
                bossSprite.innerHTML = '';
                return;
            }

            const time = Date.now() / 1000;
            const bob = Math.sin(time * 2) * 5;

            if (gameState.bossType === 'forestSpirit') {
                bossSprite.innerHTML = `
                    <svg width="200" height="120" style="transform: translateY(${bob}px)">
                        <rect x="80" y="40" width="40" height="80" fill="#4a3728" rx="5"/>
                        <rect x="70" y="60" width="60" height="50" fill="#3d2b1f" rx="8"/>
                        <path d="M70 70 Q40 50 30 70" stroke="#4a3728" stroke-width="12" fill="none" stroke-linecap="round"/>
                        <path d="M130 70 Q160 50 170 70" stroke="#4a3728" stroke-width="12" fill="none" stroke-linecap="round"/>
                        <ellipse cx="100" cy="30" rx="45" ry="30" fill="#2d5a27"/>
                        <ellipse cx="80" cy="25" rx="25" ry="20" fill="#3d8b37"/>
                        <ellipse cx="120" cy="25" rx="25" ry="20" fill="#3d8b37"/>
                        <ellipse cx="100" cy="15" rx="20" ry="15" fill="#4da347"/>
                        <ellipse cx="85" cy="75" rx="8" ry="10" fill="#7cfc00" opacity="${0.5 + Math.sin(time * 3) * 0.3}"/>
                        <ellipse cx="115" cy="75" rx="8" ry="10" fill="#7cfc00" opacity="${0.5 + Math.sin(time * 3) * 0.3}"/>
                        <ellipse cx="85" cy="78" rx="3" ry="5" fill="#0a1f0a"/>
                        <ellipse cx="115" cy="78" rx="3" ry="5" fill="#0a1f0a"/>
                        <path d="M90 95 Q100 105 110 95" stroke="#0a1f0a" stroke-width="3" fill="none"/>
                    </svg>
                `;
            } else if (gameState.bossType === 'volcanoDragon') {
                const fireFlicker = Math.sin(time * 10) * 0.3 + 0.7;
                bossSprite.innerHTML = `
                    <svg width="240" height="140" style="transform: translateY(${bob}px)">
                        <!-- Dragon head -->
                        <ellipse cx="120" cy="60" rx="60" ry="45" fill="#8b0000"/>
                        <ellipse cx="120" cy="55" rx="50" ry="35" fill="#a52a2a"/>
                        <!-- Horns -->
                        <path d="M70 30 Q60 10 75 25" stroke="#333" stroke-width="8" fill="none"/>
                        <path d="M170 30 Q180 10 165 25" stroke="#333" stroke-width="8" fill="none"/>
                        <!-- Eyes -->
                        <ellipse cx="95" cy="50" rx="12" ry="8" fill="#ff4500" opacity="${fireFlicker}"/>
                        <ellipse cx="145" cy="50" rx="12" ry="8" fill="#ff4500" opacity="${fireFlicker}"/>
                        <ellipse cx="95" cy="50" rx="5" ry="5" fill="#000"/>
                        <ellipse cx="145" cy="50" rx="5" ry="5" fill="#000"/>
                        <!-- Nostrils with smoke -->
                        <ellipse cx="105" cy="75" rx="6" ry="4" fill="#333"/>
                        <ellipse cx="135" cy="75" rx="6" ry="4" fill="#333"/>
                        <!-- Mouth -->
                        <path d="M80 90 Q120 110 160 90" stroke="#333" stroke-width="4" fill="none"/>
                        <!-- Fire breath hint -->
                        <ellipse cx="120" cy="115" rx="25" ry="15" fill="#ff6600" opacity="${fireFlicker * 0.5}"/>
                        <ellipse cx="120" cy="120" rx="15" ry="10" fill="#ffcc00" opacity="${fireFlicker * 0.3}"/>
                    </svg>
                `;
            } else if (gameState.bossType === 'iceGiant') {
                const iceGlow = Math.sin(time * 2) * 0.2 + 0.8;
                bossSprite.innerHTML = `
                    <svg width="200" height="140" style="transform: translateY(${bob}px)">
                        <!-- Body -->
                        <rect x="60" y="40" width="80" height="100" fill="#6a8caf" rx="10"/>
                        <rect x="70" y="50" width="60" height="80" fill="#87ceeb" rx="5"/>
                        <!-- Head -->
                        <ellipse cx="100" cy="30" rx="35" ry="30" fill="#a0d8ef"/>
                        <ellipse cx="100" cy="25" rx="30" ry="22" fill="#b8e2f2"/>
                        <!-- Ice crown -->
                        <path d="M70 10 L80 0 L90 15 L100 -5 L110 15 L120 0 L130 10" stroke="#fff" stroke-width="4" fill="none"/>
                        <!-- Eyes -->
                        <ellipse cx="85" cy="30" rx="8" ry="6" fill="#00ffff" opacity="${iceGlow}"/>
                        <ellipse cx="115" cy="30" rx="8" ry="6" fill="#00ffff" opacity="${iceGlow}"/>
                        <ellipse cx="85" cy="30" rx="3" ry="4" fill="#004466"/>
                        <ellipse cx="115" cy="30" rx="3" ry="4" fill="#004466"/>
                        <!-- Arms -->
                        <rect x="30" y="60" width="30" height="15" fill="#6a8caf" rx="5"/>
                        <rect x="140" y="60" width="30" height="15" fill="#6a8caf" rx="5"/>
                        <!-- Ice details -->
                        <path d="M75 70 L85 90 L95 70" stroke="#fff" stroke-width="2" fill="none" opacity="0.5"/>
                        <path d="M105 70 L115 90 L125 70" stroke="#fff" stroke-width="2" fill="none" opacity="0.5"/>
                    </svg>
                `;
            }
        }

        // ============================================
        // BOSS MECHANICS
        // ============================================
        function updateBoss(deltaTime) {
            if (!gameState.isBossLevel) return;

            const progress = gameState.snake.length / getLevelTarget(gameState.level);
            gameState.bossStage = progress < 0.33 ? 1 : progress < 0.66 ? 2 : 3;
            document.getElementById('boss-stage').textContent = gameState.bossStage;

            if (gameState.bossType === 'forestSpirit') {
                updateForestSpirit(deltaTime);
            } else if (gameState.bossType === 'volcanoDragon') {
                updateVolcanoDragon(deltaTime);
            } else if (gameState.bossType === 'iceGiant') {
                updateIceGiant(deltaTime);
            }

            // Update speed boost timer
            if (gameState.isSpeedBoosted) {
                gameState.speedBoostTimer -= deltaTime;
                if (gameState.speedBoostTimer <= 0) {
                    gameState.isSpeedBoosted = false;
                    gameState.moveInterval = 1000 / gameState.currentSpeed;
                    speedBoostIndicator.classList.add('hidden');
                }
            }
        }

        // Forest Spirit - Acorn drops
        function updateForestSpirit(deltaTime) {
            const dropRates = { 1: 3000, 2: 2000, 3: 1200 };
            gameState.bossDropTimer += deltaTime;

            if (gameState.bossDropTimer >= dropRates[gameState.bossStage]) {
                gameState.bossDropTimer = 0;
                createWarning(gameState.bossWarnings);
            }

            // Update warnings -> acorns
            gameState.bossWarnings = gameState.bossWarnings.filter(w => {
                w.timer -= deltaTime;
                if (w.timer <= 0) {
                    gameState.bossAcorns.push({ x: w.x, y: w.y, timer: 3000 });
                    return false;
                }
                return true;
            });

            // Update acorns
            gameState.bossAcorns = gameState.bossAcorns.filter(a => {
                a.timer -= deltaTime;
                return a.timer > 0;
            });
        }

        // Volcano Dragon - Expanding lava pools
        function updateVolcanoDragon(deltaTime) {
            gameState.bossDropTimer += deltaTime;

            // Consistent drop rate ~3.5 seconds
            if (gameState.bossDropTimer >= 3500) {
                gameState.bossDropTimer = 0;
                createWarning(gameState.lavaWarnings);
            }

            // Update warnings -> lava pools
            gameState.lavaWarnings = gameState.lavaWarnings.filter(w => {
                w.timer -= deltaTime;
                if (w.timer <= 0) {
                    gameState.lavaPools.push({
                        x: w.x,
                        y: w.y,
                        cells: [{ x: w.x, y: w.y }],
                        expandTimer: 0,
                        maxSize: 3
                    });
                    return false;
                }
                return true;
            });

            // Expand lava pools
            gameState.lavaPools.forEach(pool => {
                pool.expandTimer += deltaTime;
                if (pool.expandTimer >= 1500 && pool.cells.length < pool.maxSize * pool.maxSize) {
                    pool.expandTimer = 0;
                    expandLavaPool(pool);
                }
            });
        }

        function expandLavaPool(pool) {
            const newCells = [];
            pool.cells.forEach(cell => {
                const neighbors = [
                    { x: cell.x + 1, y: cell.y },
                    { x: cell.x - 1, y: cell.y },
                    { x: cell.x, y: cell.y + 1 },
                    { x: cell.x, y: cell.y - 1 }
                ];
                neighbors.forEach(n => {
                    if (n.x >= 0 && n.x < CONFIG.gridSize && n.y >= 0 && n.y < CONFIG.gridSize) {
                        if (!pool.cells.some(c => c.x === n.x && c.y === n.y) &&
                            !newCells.some(c => c.x === n.x && c.y === n.y)) {
                            if (Math.random() < 0.3) {
                                newCells.push(n);
                            }
                        }
                    }
                });
            });
            pool.cells.push(...newCells.slice(0, 2));
        }

        // Ice Giant - Snowballs and icicles
        function updateIceGiant(deltaTime) {
            gameState.snowballTimer += deltaTime;
            gameState.icicleTimer += deltaTime;

            // Snowballs (create ice patches)
            const snowballRate = gameState.bossStage === 3 ? 2500 : 3500;
            if (gameState.snowballTimer >= snowballRate) {
                gameState.snowballTimer = 0;
                createIcePatch();
            }

            // Icicles (stage 2+)
            if (gameState.bossStage >= 2) {
                const icicleRate = gameState.bossStage === 3 ? 2000 : 3000;
                if (gameState.icicleTimer >= icicleRate) {
                    gameState.icicleTimer = 0;
                    createWarning(gameState.icicleWarnings);
                }
            }

            // Update ice patches
            gameState.icePatches = gameState.icePatches.filter(p => {
                p.timer -= deltaTime;
                return p.timer > 0;
            });

            // Update icicle warnings -> icicles
            gameState.icicleWarnings = gameState.icicleWarnings.filter(w => {
                w.timer -= deltaTime;
                if (w.timer <= 0) {
                    gameState.icicles.push({ x: w.x, y: w.y, timer: 3000 });
                    return false;
                }
                return true;
            });

            // Update icicles
            gameState.icicles = gameState.icicles.filter(i => {
                i.timer -= deltaTime;
                return i.timer > 0;
            });
        }

        function createIcePatch() {
            let x, y, attempts = 0;
            do {
                x = Math.floor(Math.random() * (CONFIG.gridSize - 4));
                y = Math.floor(Math.random() * (CONFIG.gridSize - 4));
                attempts++;
            } while (attempts < 50 && gameState.snake.some(s =>
                s.x >= x && s.x < x + 4 && s.y >= y && s.y < y + 4
            ));

            if (attempts < 50) {
                gameState.icePatches.push({ x, y, timer: 5000 });
            }
        }

        function createWarning(warningArray) {
            let pos, attempts = 0;
            do {
                pos = {
                    x: Math.floor(Math.random() * (CONFIG.gridSize - 2)) + 1,
                    y: Math.floor(Math.random() * (CONFIG.gridSize - 2)) + 1
                };
                attempts++;
            } while (attempts < 50 && (
                gameState.snake.some(s => s.x === pos.x && s.y === pos.y) ||
                (gameState.food && gameState.food.x === pos.x && gameState.food.y === pos.y)
            ));

            if (attempts < 50) {
                warningArray.push({ x: pos.x, y: pos.y, timer: 2000 });
            }
        }

        // ============================================
        // BOSS DRAWING
        // ============================================
        function drawBossElements(biome) {
            // Forest Spirit acorns
            drawWarnings(gameState.bossWarnings);
            gameState.bossAcorns.forEach(acorn => {
                const x = acorn.x * CONFIG.cellSize + CONFIG.cellSize / 2;
                const y = acorn.y * CONFIG.cellSize + CONFIG.cellSize / 2;
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.ellipse(x, y + 2, 8, 10, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                ctx.ellipse(x, y - 6, 10, 5, 0, 0, Math.PI);
                ctx.fill();
            });

            // Volcano Dragon lava
            drawWarnings(gameState.lavaWarnings);
            gameState.lavaPools.forEach(pool => {
                pool.cells.forEach(cell => {
                    const x = cell.x * CONFIG.cellSize;
                    const y = cell.y * CONFIG.cellSize;
                    const time = Date.now() / 200;
                    const flicker = Math.sin(time + cell.x + cell.y) * 0.2 + 0.8;

                    ctx.fillStyle = `rgba(255, 69, 0, ${flicker})`;
                    ctx.fillRect(x + 1, y + 1, CONFIG.cellSize - 2, CONFIG.cellSize - 2);
                    ctx.fillStyle = `rgba(255, 200, 0, ${flicker * 0.5})`;
                    ctx.fillRect(x + 4, y + 4, CONFIG.cellSize - 8, CONFIG.cellSize - 8);
                });
            });

            // Ice Giant elements
            // Ice patches
            gameState.icePatches.forEach(patch => {
                const x = patch.x * CONFIG.cellSize;
                const y = patch.y * CONFIG.cellSize;
                const size = 4 * CONFIG.cellSize;

                ctx.fillStyle = 'rgba(135, 206, 235, 0.4)';
                ctx.fillRect(x, y, size, size);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, size, size);

                // Sparkle effect
                const time = Date.now() / 300;
                for (let i = 0; i < 3; i++) {
                    const sx = x + Math.sin(time + i) * 30 + size / 2;
                    const sy = y + Math.cos(time + i * 2) * 30 + size / 2;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(sx, sy, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Icicle warnings and icicles
            drawWarnings(gameState.icicleWarnings);
            gameState.icicles.forEach(icicle => {
                const x = icicle.x * CONFIG.cellSize + CONFIG.cellSize / 2;
                const y = icicle.y * CONFIG.cellSize + CONFIG.cellSize / 2;

                ctx.fillStyle = '#a0d8ef';
                ctx.beginPath();
                ctx.moveTo(x, y - 10);
                ctx.lineTo(x - 8, y + 10);
                ctx.lineTo(x + 8, y + 10);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(x - 2, y - 5);
                ctx.lineTo(x - 4, y + 5);
                ctx.lineTo(x, y + 3);
                ctx.closePath();
                ctx.fill();
            });
        }

        function drawWarnings(warnings) {
            warnings.forEach(w => {
                const x = w.x * CONFIG.cellSize;
                const y = w.y * CONFIG.cellSize;
                const alpha = 0.3 + Math.sin(Date.now() / 100) * 0.2;

                ctx.fillStyle = `rgba(255, 68, 68, ${alpha})`;
                ctx.beginPath();
                ctx.arc(x + CONFIG.cellSize / 2, y + CONFIG.cellSize / 2, CONFIG.cellSize / 2 - 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }

        // ============================================
        // OBSTACLE & FOOD SPAWNING
        // ============================================
        function generateObstacles() {
            gameState.obstacles = [];
            const count = getObstacleCount(gameState.level);

            for (let i = 0; i < count; i++) {
                let pos, attempts = 0;
                do {
                    pos = {
                        x: Math.floor(Math.random() * (CONFIG.gridSize - 4)) + 2,
                        y: Math.floor(Math.random() * (CONFIG.gridSize - 4)) + 2
                    };
                    attempts++;
                } while (attempts < 100 && (
                    isPositionOccupied(pos) ||
                    isNearSnakeStart(pos) ||
                    isNearOtherObstacle(pos)
                ));

                if (attempts < 100) {
                    gameState.obstacles.push(pos);
                }
            }
        }

        function isPositionOccupied(pos) {
            if (gameState.snake.some(s => s.x === pos.x && s.y === pos.y)) return true;
            if (gameState.food && gameState.food.x === pos.x && gameState.food.y === pos.y) return true;
            if (gameState.obstacles.some(o => o.x === pos.x && o.y === pos.y)) return true;
            return false;
        }

        function isNearSnakeStart(pos) {
            const startX = Math.floor(CONFIG.gridSize / 4);
            const startY = Math.floor(CONFIG.gridSize / 2);
            return Math.abs(pos.x - startX) < 5 && Math.abs(pos.y - startY) < 3;
        }

        function isNearOtherObstacle(pos) {
            return gameState.obstacles.some(o =>
                Math.abs(o.x - pos.x) < 2 && Math.abs(o.y - pos.y) < 2
            );
        }

        function spawnFood() {
            let pos, attempts = 0;
            do {
                pos = {
                    x: Math.floor(Math.random() * (CONFIG.gridSize - 2)) + 1,
                    y: Math.floor(Math.random() * (CONFIG.gridSize - 2)) + 1
                };
                attempts++;
            } while (attempts < 100 && (
                gameState.snake.some(s => s.x === pos.x && s.y === pos.y) ||
                gameState.obstacles.some(o => o.x === pos.x && o.y === pos.y) ||
                gameState.bossAcorns.some(a => a.x === pos.x && a.y === pos.y) ||
                gameState.lavaPools.some(p => p.cells.some(c => c.x === pos.x && c.y === pos.y)) ||
                gameState.icicles.some(i => i.x === pos.x && i.y === pos.y)
            ));

            gameState.food = pos;
        }

        // ============================================
        // GAME STATE MANAGEMENT
        // ============================================
        function updateHUD() {
            document.getElementById('level-display').textContent = gameState.level;
            document.getElementById('length-display').textContent = gameState.snake.length;
            document.getElementById('target-display').textContent = getLevelTarget(gameState.level);
            document.getElementById('speed-display').textContent = gameState.currentSpeed;
        }

        function gameOver() {
            gameState.gameStatus = 'gameover';
            document.getElementById('final-level').textContent = gameState.level;
            document.getElementById('final-length').textContent = gameState.snake.length;
            gameOverScreen.classList.remove('hidden');
            bossHud.classList.add('hidden');
            bossSprite.innerHTML = '';
            speedBoostIndicator.classList.add('hidden');
        }

        function levelComplete() {
            gameState.gameStatus = 'levelcomplete';
            document.getElementById('completed-level').textContent = gameState.level;

            const titleEl = document.getElementById('level-complete-title');
            const nextBtn = document.getElementById('next-level-btn');

            if (gameState.isBossLevel) {
                titleEl.textContent = 'BOSS DEFEATED!';
                titleEl.classList.add('victory-text');
                nextBtn.textContent = gameState.level >= CONFIG.maxLevel ? 'VICTORY!' : 'NEXT BIOME';
            } else {
                titleEl.textContent = 'LEVEL COMPLETE!';
                titleEl.classList.remove('victory-text');
                nextBtn.textContent = 'NEXT LEVEL';
            }

            levelCompleteScreen.classList.remove('hidden');
            bossHud.classList.add('hidden');
            bossSprite.innerHTML = '';
            speedBoostIndicator.classList.add('hidden');
        }

        function startLevel(level) {
            const lvl = Number(level) || 1;
            gameState.level = Math.min(Math.max(1, lvl), CONFIG.maxLevel);
            gameState.gameStatus = 'playing';

            // Set speed based on level
            gameState.currentSpeed = getLevelSpeed(gameState.level);
            gameState.moveInterval = 1000 / gameState.currentSpeed;

            // Boss setup
            gameState.isBossLevel = getBossLevel(gameState.level);
            gameState.bossType = getBossType(gameState.level);
            gameState.bossStage = 1;

            // Reset boss-specific state
            gameState.bossAcorns = [];
            gameState.bossWarnings = [];
            gameState.bossDropTimer = 0;
            gameState.lavaPools = [];
            gameState.lavaWarnings = [];
            gameState.icePatches = [];
            gameState.icicles = [];
            gameState.icicleWarnings = [];
            gameState.snowballTimer = 0;
            gameState.icicleTimer = 0;
            gameState.isSpeedBoosted = false;
            gameState.speedBoostTimer = 0;
            gameState.lastMoveTime = 0;

            // Apply biome theme
            const biome = getBiome(gameState.level);
            const biomeKey = getBiomeKey(gameState.level);
            applyBiomeTheme(biome);
            initParticles(biomeKey);

            initSnake();
            generateObstacles();
            spawnFood();
            updateHUD();

            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            levelCompleteScreen.classList.add('hidden');
            speedBoostIndicator.classList.add('hidden');

            if (gameState.isBossLevel) {
                bossHud.classList.remove('hidden');
                const bossNames = {
                    'forestSpirit': 'FOREST SPIRIT',
                    'volcanoDragon': 'VOLCANO DRAGON',
                    'iceGiant': 'ICE GIANT'
                };
                document.getElementById('boss-name').textContent = bossNames[gameState.bossType];
                showBossWarning();
            } else {
                bossHud.classList.add('hidden');
            }
        }

        function showBossWarning() {
            bossWarning.classList.remove('hidden');
            setTimeout(() => {
                bossWarning.classList.add('hidden');
            }, 2000);
        }

        // ============================================
        // INPUT HANDLING
        // ============================================
        document.addEventListener('keydown', (e) => {
            if (gameState.gameStatus !== 'playing') return;

            const keyMap = {
                'ArrowUp': { x: 0, y: -1 }, 'w': { x: 0, y: -1 }, 'W': { x: 0, y: -1 },
                'ArrowDown': { x: 0, y: 1 }, 's': { x: 0, y: 1 }, 'S': { x: 0, y: 1 },
                'ArrowLeft': { x: -1, y: 0 }, 'a': { x: -1, y: 0 }, 'A': { x: -1, y: 0 },
                'ArrowRight': { x: 1, y: 0 }, 'd': { x: 1, y: 0 }, 'D': { x: 1, y: 0 }
            };

            const newDir = keyMap[e.key];
            if (newDir) {
                if (newDir.x !== -gameState.direction.x || newDir.y !== -gameState.direction.y) {
                    gameState.nextDirection = newDir;
                }
                e.preventDefault();
            }
        });

        // ============================================
        // BUTTON HANDLERS
        // ============================================
        document.getElementById('start-btn').addEventListener('click', () => startLevel(1));
        document.getElementById('go-btn').addEventListener('click', () => {
            const level = parseInt(document.getElementById('level-input').value, 10) || 1;
            startLevel(level);
        });
        document.getElementById('restart-btn').addEventListener('click', () => startLevel(1));
        document.getElementById('menu-btn').addEventListener('click', () => {
            gameState.gameStatus = 'menu';
            gameOverScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            bossSprite.innerHTML = '';
            applyBiomeTheme(BIOMES.forest);
            initParticles('forest');
        });
        document.getElementById('next-level-btn').addEventListener('click', () => {
            if (gameState.level < CONFIG.maxLevel) {
                startLevel(gameState.level + 1);
            } else {
                gameState.gameStatus = 'menu';
                levelCompleteScreen.classList.add('hidden');
                startScreen.classList.remove('hidden');
                applyBiomeTheme(BIOMES.forest);
                initParticles('forest');
            }
        });

        // ============================================
        // GAME LOOP
        // ============================================
        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            const biome = getBiome(gameState.level);
            const biomeKey = getBiomeKey(gameState.level);

            updateParticles(biome, biomeKey);

            if (gameState.gameStatus === 'playing') {
                updateBoss(deltaTime);
                drawBossSprite();

                gameState.lastMoveTime += deltaTime;
                if (gameState.lastMoveTime >= gameState.moveInterval) {
                    gameState.lastMoveTime = 0;
                    moveSnake();
                }

                drawBackground(biome);
                drawObstacles(biome, biomeKey);
                drawBossElements(biome);
                drawFood(biome);
                drawSnake(biome);
            }

            requestAnimationFrame(gameLoop);
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        applyBiomeTheme(BIOMES.forest);
        initParticles('forest');
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
